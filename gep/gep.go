package gep

import (
	"bytes"
	"fmt"
	"github.com/daviddengcn/go-villa"
	"strconv"
	"strings"
	"unicode"
)

// GepParts is the data-structure for parsed results
type GepParts struct {
	// A slice of parts. Elements are all generated by calling to Interface.GenXxxPart()
	Parts villa.Slice

	// All imported package names
	Imports villa.StrSet
	// All included and required paths
	Depends villa.StrSet

	// Whether the root source is marked as includeonly
	IncludeOnly bool
}

// Interface defines some actions for parsing
type Interface interface {
	// Load a file with specified path. The path is extracted from include/require premitives
	Load(path villa.Path) (string, error)

	// Generate a part object for a raw source
	GenRawPart(src string) interface{}

	// Generate a part object for a code source <% %>
	GenCodePart(src string) interface{}

	// Generate a part object for a evaluation source <%= %>
	GenEvalPart(src string) interface{}

	// Output an error message
	Error(message string)
}

// Parse parses the source with a predefined Interface.
func Parse(f Interface, src string) (parts *GepParts, err error) {
	p := &parser{Interface: f, GepParts: &GepParts{}}
	err = p.parse(src)
	if err != nil {
		return nil, err
	}

	return p.GepParts, nil
}

// The internal parser struct
type parser struct {
	Interface
	*GepParts

	included, required villa.StrSet
	includeStack       villa.StringSlice
}


/** Implementation **/

const (
	ct_LOCAL = iota
	ct_GLOBAL
	ct_EVAL
	ct_HTML
	ct_IGNORE
)

func (p *parser) addRaw(src string) {
	if len(src) == 0 {
		return
	} // if
	p.Parts = append(p.Parts, p.GenRawPart(src))
}

func sepGlobal(src string) (cmd, remain string) {
	j := len(src)
	for i, r := range src {
		if !unicode.IsLetter(r) {
			j = i
			break
		}
	}

	return src[:j], src[j:]
}

func (p *parser) include(path villa.Path) error {
	p.Depends.Put(path.S())
	src, err := p.Load(path)

	if err != nil {
		return err
	}

	p.includeStack.Add(path)
	p.parse(src)
	p.includeStack.Pop()

	return nil
}

func (p *parser) addCode(src string, codeType int) {
	switch codeType {
	case ct_LOCAL:
		p.Parts.Add(p.GenCodePart(src))

	case ct_EVAL:
		p.Parts.Add(p.GenEvalPart(src))

	case ct_IGNORE:
		// Do nothing

	case ct_GLOBAL:
		cmd, src := sepGlobal(src)
		switch cmd {
		case "import":
			imports := strings.Split(src, ",")
			for _, imp := range imports {
				impstr, err := strconv.Unquote(strings.TrimSpace(imp))
				if err == nil {
					p.Imports.Put(impstr)
				} else {
					p.Error(fmt.Sprintf("import %s error: %v", imp, err))
				}
			}

		case "include":
			imp := strings.TrimSpace(src)
			inc, err := strconv.Unquote(imp)
			if err == nil {
				if !p.included.In(inc) {
					p.included.Put(inc)
					p.required.Put(inc)
					err = p.include(villa.Path(inc))
					if err != nil {
						p.Error(fmt.Sprintf("include %s failed: %v", inc, err))
					}
					p.included.Delete(inc)
				}
			} else {
				p.Error(fmt.Sprintf("include %s error: %v", imp, err))
			}

		case "require":
			imp := strings.TrimSpace(src)
			inc, err := strconv.Unquote(imp)
			if err == nil {
				if !p.required.In(inc) {
					p.required.Put(inc)
					err = p.include(villa.Path(inc))
					if err != nil {
						p.Error(fmt.Sprintf("require %s failed: %v", inc, err))
					}
				}
			} else {
				p.Error(fmt.Sprintf("require %s error: %v", imp, err))
			}

		case "includeonly":
			if len(p.includeStack) == 0 {
				p.IncludeOnly = true
			}

		default:
			p.Error(fmt.Sprintf("Unknown command %s, ignored!", cmd))
		}
	}
}

func (p *parser) parse(src string) (err error) {
	/*
		Status Transform

		             .-- R(eady) <---.
		         (<)/                 |
		           V                  |
		           C0                 |(>)
		        (%)|   ___(%)____     |
		           V  /          V    |
		tp=LOCAL   C1 ---> C2 ---> C3-'
		           | \        (%)
		           |  \(=)
		tp=EVAL    |   `-> C2 ...
		           |\(!)
		tp=GLOBAL  | `---> C2 ...
		            \(#)
		tp=IGNORED   `---> C2 ...
	*/
	const (
		R = iota
		C0
		C1
		C2
		C3
	)
	status, tp := R, ct_GLOBAL
	var source bytes.Buffer
	for _, r := range src {
		switch status {
		case R:
			switch r {
			case '<':
				status = C0

			default:
				source.WriteRune(r)
			}
		case C0:
			switch r {
			case '%':
				status, tp = C1, ct_LOCAL
				p.addRaw(source.String())
				source.Reset()

			default:
				status = R
				source.WriteRune('<') // the < causing R->C0
				source.WriteRune(r)
			}

		case C1:
			switch r {
			case '=':
				status, tp = C2, ct_EVAL

			case '!':
				status, tp = C2, ct_GLOBAL

			case '#':
				status, tp = C2, ct_IGNORE

			case '%':
				status = C3

			default:
				status = C2
				source.WriteRune(r)
			}

		case C2:
			switch r {
			case '%':
				status = C3

			default:
				source.WriteRune(r)
			}

		case C3:
			switch r {
			case '>':
				status = R
				p.addCode(source.String(), tp)
				source.Reset()

			default:
				status = C2
				source.WriteRune('%') // the % causing C2->C3
				source.WriteRune(r)
			}
		} // switch status
	} // for r

	switch status {
	case R:
		if source.Len() > 0 {
			p.addRaw(source.String())
		}
	default:
		p.Error("Unclosed tag")
	}
	return nil
}
